---
title: "Bayesian GLM Part2"
author: "Murray Logan"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: show
    collapse: no
    df_print: paged
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: textmate
    theme: spacelab
    toc: yes
    toc_float: yes
    css: ../resources/style.css
  pdf_document:
    df_print: default
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: tango
    latex_engine: xelatex
    number_sections: yes
    toc_depth: 2
  word_document:
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: tango
    toc: yes
    toc_depth: 2
output_dir: "docs"
documentclass: article
fontsize: 12pt
mainfont: Arial
mathfont: LiberationMono
monofont: DejaVu Sans Mono
classoption: a4paper
bibliography: ../resources/references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)
```

# Preparations

Load the necessary libraries

```{r libraries, results='markdown', eval=TRUE}
library(rstanarm)   #for fitting models in STAN
library(coda)       #for diagnostics
library(bayesplot)  #for diagnostics
library(rstan)      #for interfacing with STAN
library(emmeans)    #for marginal means etc
library(broom)      #for tidying outputs
library(tidybayes)  #for more tidying outputs
library(ggeffects)  #for partial plots
library(tidyverse)  #for data wrangling etc
```

# Scenario

@Polis-1998-490 were intested in modelling the presence/absence of lizards (<i>Uta sp.</i>) against the perimeter to area ratio of 19 islands in the Gulf of California.

![Uta lizard](../resources/uta.jpg){width="200" height="137"}

Format of polis.csv data file

ISLAND       RATIO   PA
------------ ------- ----
Bota         15.41   1
Cabeza       5.63    1
Cerraja      25.92   1
Coronadito   15.17   0
..           ..      ..

------------ -----------------------------------------------------------------------------------------
**ISLAND**   Categorical listing of the name of the 19 islands used - variable not used in analysis.
**RATIO**    Ratio of perimeter to area of the island.
**PA**       Presence (1) or absence (0) of *Uta* lizards on island.
------------ -----------------------------------------------------------------------------------------




The aim of the analysis is to investigate the relationship between island parimeter to area ratio and the presence/absence of Uta lizards.

# Read in the data

```{r readData, results='markdown', eval=TRUE}
polis = read_csv('../data/polis.csv', trim_ws=TRUE)
glimpse(polis)
head(polis)
str(polis)
```

# Exploratory data analysis

Model formula:
$$
\begin{align}
y_i &\sim{} \mathcal{Bin}(n, p_i)\\
ln\left(\frac{p_i}{1-p_i}\right) &= \beta_0 + \beta_1 x_i\\
\beta_0 &\sim{} \mathcal{N}(0,10)\\
\beta_1 &\sim{} \mathcal{N}(0,1)\\
\end{align}
$$


# Fit the model

```{r}
polis.rstanopt = stan_glm(PA ~ RATIO, data = polis,
                         algorithm = 'optimizing') 
prior_summary(polis.rstanopt)
#this doesn't go through the sampling routine, it only does the optimizing and gives us a chance to see what might be a useful prior, without giving us the full model

#It says 0|10 and 0|2.5. 
#However, it is important to set priors ourselves. 

summary(polis.rstanopt)
#We get a quick idea if the model is a reasonable model. It has the estimated median and sd, and 95% confidence intervals
```


```{r}
polis.rstanarm = stan_glm(PA~RATIO, data = polis, family = binomial(), 
iter = 5000, warmup = 500, chains = 3, thin = 2, refresh = 0)
```

We now start building our model using the prior on the intercept and the prior on our slope:

```{r fitModel, cache=T}
polis.rstanarm = stan_glm(PA~RATIO, data = polis, family = binomial(), 
iter = 5000, warmup = 500, chains = 3, thin = 2, refresh = 0,
prior_intercept = normal(0,10, autoscale = F),
prior = normal(0,1, autoscale = F))

save(polis.rstanarm, file = '../data/polis.rstanarm.RData')
```

Were our priors overly influential? Were the chains well mixed?

# Model validation

```{r}
load(file = '../data/polis.rstanarm.RData')
posterior_vs_prior(polis.rstanarm, color_by = 'vs', group_by = T,
                   facet_args = list(scales='free_y'))
```

The priors are far far wider than the posteriors, therefore they're not being influential. They're sufficiently vague, and thus not influenting what the posterior should be.

```{r}
stan_trace(polis.rstanarm)
```
```{r}
stan_ess(polis.rstanarm)
#concerned if the engine was efficiently working
```

```{r}
stan_rhat(polis.rstanarm)
#concerned with what the estimates might be
```


Although both the rhat and ESS are concerned with different things, the solution for both of them is to thin the priors.

```{r}
stan_ac(polis.rstanarm)
```

If we increase the thinning, there will be less lag. For example, if we go from thin = 2 to thin = 4.

```{r}
pp_check(polis.rstanarm, x = polis$RATIO, plotfun = 'error_scatter_avg_vs_x')
#this is a proximate residual plot
```

```{r}
resid = residuals(polis.rstanarm)
fit = fitted(polis.rstanarm)
ggplot(data = NULL) + geom_point(aes(y=resid, x = fit))
```


# Model investigation / hypothesis testing

```{r}
ggpredict(polis.rstanarm) %>% plot
```


```{r}
ggemmeans(polis.rstanarm, ~RATIO) %>% plot
```

```{r}
tidyMCMC(polis.rstanarm$stanfit, conf.int = T, conf.method = 'HPDinterval', rhat = T, ess = T)
```

```{r}
polis.r2 = bayes_R2(polis.rstanarm)
hist(polis.r2)
```

```{r}
polis.r2 %>% median_hdi
```


#Predictions

We can also extract these high probability density intervals manually:

```{r}
polis.mcmc = as.matrix(polis.rstanarm)
nrow(polis.mcmc) #3375
head(polis.mcmc) #and we can ask any question we want from this
```

```{r}
hist(polis.mcmc[,'RATIO'])
```


Backtransformed into an odds ratio scale:

```{r}
hist(exp(polis.mcmc[,'RATIO']))
```

```{r}
exp(polis.mcmc[,'RATIO']) %>% median_hdi
```

For every 1 unit change in RATIO, we have a 23% change.
It was in a log ratio scale, and after the back transform y=0.77 is not additive, but multiplicative.


# Summary figures

```{r}
polis.list= with(polis, list(RATIO = seq(min(RATIO), max(RATIO), len = 100)))
newdata = emmeans(polis.rstanarm, ~RATIO, at = polis.list, type = 'response') %>% as.data.frame
head(newdata)
```

```{r}
ggplot(newdata, aes(y = prob, x = RATIO)) +
  geom_point(data = polis, aes(y=PA)) +
  geom_line() +
  geom_ribbon(aes(ymin = lower.HPD, ymax = upper.HPD), fill = 'blue', alpha = 0.3) +
  scale_y_continuous('PA') +
  scale_x_continuous('RATIO') +
  theme_classic()
```



# References
